// Generated by IcedCoffeeScript 1.7.1-a
(function() {
  var Assertions, E, GithubAssert, SocialNetworkAssert, TwitterAssert, UnspecifiedAssert, log,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  E = require('./err').E;

  log = require('./log');

  Assertions = (function() {
    function Assertions() {
      this._list = [];
      this._lookup = {};
      this._unspecified = [];
    }

    Assertions.prototype.push = function(a) {
      this._list.push(a);
      return this._lookup[a.key] = a;
    };

    Assertions.prototype.found = function(type_s) {
      var ret;
      if ((ret = this._lookup[type_s]) == null) {
        ret = new UnspecifiedAssert(type_s);
        this._unspecified.push(ret);
      }
      ret.found();
      return ret;
    };

    Assertions.prototype.met = function() {
      return this._met;
    };

    Assertions.prototype.clean = function() {
      return this._met && !this._unspecified.length;
    };

    Assertions.prototype.check = function() {
      var a, ret, _i, _j, _len, _len1, _ref, _ref1;
      ret = true;
      _ref = this._list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        if (!a.check()) {
          ret = false;
        }
      }
      _ref1 = this._unspecified;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        a = _ref1[_j];
        a.generate_warning();
      }
      this._met = ret;
      return ret;
    };

    return Assertions;

  })();

  SocialNetworkAssert = (function() {
    function SocialNetworkAssert(key, val) {
      this.key = key;
      this.val = val;
    }

    SocialNetworkAssert.make = function(key, val) {
      var err, out;
      err = out = null;
      out = (function() {
        switch (key) {
          case 'github':
            return new GithubAssert(key, val);
          case 'twitter':
            return new TwitterAssert(key, val);
          default:
            err = new E.BadAssertionError("unknown assertion type: " + key);
            return null;
        }
      })();
      return [err, out];
    };

    SocialNetworkAssert.prototype.set_proof_service_object = function(o) {
      return this._username = o.username;
    };

    SocialNetworkAssert.prototype.found = function() {
      return this._found = true;
    };

    SocialNetworkAssert.prototype.success = function(u) {
      this._uri = u;
      return this._success = true;
    };

    SocialNetworkAssert.prototype.check = function() {
      var ret;
      ret = false;
      if (!this._success) {
        log.error("Failed assertion: " + this.key + ":" + this.val + " wasn't found");
      } else if (this._username !== this.val) {
        log.error("Failed assertion for '" + this.key + "': " + this.val + " expected, but found " + this._username);
      } else {
        ret = true;
      }
      return ret;
    };

    return SocialNetworkAssert;

  })();

  TwitterAssert = (function(_super) {
    __extends(TwitterAssert, _super);

    function TwitterAssert() {
      return TwitterAssert.__super__.constructor.apply(this, arguments);
    }

    return TwitterAssert;

  })(SocialNetworkAssert);

  GithubAssert = (function(_super) {
    __extends(GithubAssert, _super);

    function GithubAssert() {
      return GithubAssert.__super__.constructor.apply(this, arguments);
    }

    return GithubAssert;

  })(SocialNetworkAssert);

  UnspecifiedAssert = (function(_super) {
    __extends(UnspecifiedAssert, _super);

    function UnspecifiedAssert() {
      return UnspecifiedAssert.__super__.constructor.apply(this, arguments);
    }

    UnspecifiedAssert.prototype.generate_warning = function() {
      if (this._success) {
        return log.warn("Unspecified assertion: " + this.key + ":" + this._username + " is also true");
      }
    };

    return UnspecifiedAssert;

  })(Assert);

  exports.parse = function(v) {
    var ass, assert, err, m, out, _i, _len, _ref;
    out = new Assertions();
    for (_i = 0, _len = v.length; _i < _len; _i++) {
      ass = v[_i];
      if ((m = ass.match(/^([^\s:]+):(.*)$/))) {
        _ref = Assert.make(m[1], m[2]), err = _ref[0], assert = _ref[1];
      } else {
        err = new E.BadAssertionError("Bad assertion, couldn't parse: " + ass);
      }
      if (err != null) {
        break;
      }
      out.push(assert);
    }
    if (err != null) {
      out = null;
    }
    return [err, out];
  };

}).call(this);
