// Generated by IcedCoffeeScript 1.7.1-a
(function() {
  var Assert, Assertions, E, GithubAssert, KeyAssert, SocialNetworkAssert, TwitterAssert, WebAssert, keycmp, log, urlmod,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  E = require('./err').E;

  log = require('./log');

  urlmod = require('url');

  Assertions = (function() {
    function Assertions() {
      this._list = [];
      this._lookup = {};
      this._unspecified = [];
    }

    Assertions.prototype.push = function(a) {
      var existing;
      this._list.push(a);
      existing = this._lookup[a.key];
      if (!existing || existing.merge(a)) {
        return this._lookup[a.key] = a;
      }
    };

    Assertions.prototype.found = function(type_s, unspecified) {
      var err, key, ret, _ref;
      if (unspecified == null) {
        unspecified = true;
      }
      key = (function() {
        switch (type_s) {
          case 'generic_web_site':
            return 'web';
          default:
            return type_s;
        }
      })();
      ret = null;
      if (((ret = this._lookup[key]) == null) && unspecified) {
        _ref = new Assert.make(key), err = _ref[0], ret = _ref[1];
        if (err != null) {
          log.error("Error unhandling unspecified assertion: " + err.messge);
        } else {
          ret.set_unspecified(true);
          this._unspecified.push(ret);
        }
      }
      if (ret != null) {
        ret.found();
      }
      return ret;
    };

    Assertions.prototype.met = function() {
      return this._met;
    };

    Assertions.prototype.clean = function() {
      return this._met && !this._unspecified.length;
    };

    Assertions.prototype.check = function() {
      var a, ret, _i, _j, _len, _len1, _ref, _ref1;
      ret = true;
      _ref = this._list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        if (!a.check()) {
          ret = false;
        }
      }
      _ref1 = this._unspecified;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        a = _ref1[_j];
        a.generate_unspecified_warning();
      }
      this._met = ret;
      return ret;
    };

    return Assertions;

  })();

  Assert = (function() {
    function Assert(key, val) {
      this.key = key;
      this.val = val;
      this._unspecified = false;
    }

    Assert.make = function(key, val) {
      var err, klass, out;
      err = out = null;
      klass = (function() {
        switch (key) {
          case 'github':
            return GithubAssert;
          case 'twitter':
            return TwitterAssert;
          case 'web':
            return WebAssert;
          case 'key':
            return KeyAssert;
          default:
            err = new E.BadAssertionError("unknown assertion type: " + key);
            return null;
        }
      })();
      if (klass != null) {
        out = new klass(key, val);
        if ((val != null) && ((err = out.parse_check()) != null)) {
          out = null;
        }
      }
      return [err, out];
    };

    Assert.prototype.merge = function(a) {
      return false;
    };

    Assert.prototype.found = function() {
      return this._found = true;
    };

    Assert.prototype.parse_check = function() {
      return null;
    };

    Assert.prototype.set_unspecified = function() {
      return this._unspecified = true;
    };

    Assert.prototype.success = function(u) {
      this._uri = u;
      this._success = true;
      return this;
    };

    Assert.prototype.check = function() {
      if (!this._success) {
        log.error("Failed assertion: " + this.key + ":" + this.val + " wasn't found");
        return false;
      } else {
        return true;
      }
    };

    return Assert;

  })();

  keycmp = function(k1, k2) {
    var rev;
    rev = function(x) {
      var c;
      return ((function() {
        var _i, _results;
        _results = [];
        for (_i = x.length - 1; _i >= 0; _i += -1) {
          c = x[_i];
          _results.push(c);
        }
        return _results;
      })()).join('');
    };
    if (k2.length > k1.length) {
      return false;
    }
    k1 = rev(k1.toLowerCase());
    k2 = rev(k2.toLowerCase());
    return k1.indexOf(k2) === 0;
  };

  KeyAssert = (function(_super) {
    __extends(KeyAssert, _super);

    function KeyAssert() {
      return KeyAssert.__super__.constructor.apply(this, arguments);
    }

    KeyAssert.prototype.parse_check = function() {
      var _ref;
      if (!(this.val.match(/^[a-fA-F0-9]+$/))) {
        return new Error("expected a hexidecimal key fingerprint");
      } else if (!((_ref = this.val.length) === 8 || _ref === 16 || _ref === 40)) {
        return new Error("expected a short, long or full fingerprint");
      } else {
        return null;
      }
    };

    KeyAssert.prototype.set_payload = function(f) {
      return this._fingerprint = f;
    };

    KeyAssert.prototype.check = function() {
      var ret;
      ret = KeyAssert.__super__.check.call(this);
      if (!ret) {

      } else if (!keycmp(this._fingerprint, this.val)) {
        log.error("Key mismatch: " + this.val + " doesn't match " + this._fingerprint);
      } else {
        ret = true;
      }
      return ret;
    };

    return KeyAssert;

  })(Assert);

  WebAssert = (function(_super) {
    __extends(WebAssert, _super);

    function WebAssert(key, val) {
      WebAssert.__super__.constructor.call(this, key, val);
      if (val != null) {
        this._seek = [val];
      }
      this._found_sites = {};
    }

    WebAssert.prototype.merge = function(wa2) {
      this._seek = this._seek.concat(wa2._seek);
      return true;
    };

    WebAssert.prototype.set_payload = function(o) {
      var u, _ref;
      u = urlmod.format(o != null ? (_ref = o.body) != null ? _ref.service : void 0 : void 0).toLowerCase();
      return this._found_sites[u] = true;
    };

    WebAssert.prototype.parse_check = function() {
      var u;
      u = urlmod.parse(this.val);
      if (!(u.hostname.match(/[a-zA-Z]\.[a-zA-Z]/))) {
        return new Error("no hostname given");
      } else if ((u.pathname != null) && (u.pathname !== '/')) {
        return new Error("can't specify a path");
      } else if (u.port != null) {
        return new Error("can't specify a port");
      } else {
        if (u.protocol == null) {
          u.protocol = "https:";
        }
        this.val = u.format();
        return null;
      }
    };

    WebAssert.prototype.check = function() {
      var ret, s, _i, _len, _ref;
      ret = true;
      _ref = this._seek;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (!(!this._found_sites[s])) {
          continue;
        }
        log.error("Web ownership assertion failed for '" + s + "'");
        ret = false;
      }
      return ret;
    };

    WebAssert.prototype.generate_unspecified_warning = function() {
      var k, v;
      return log.warn("Assertion for web sites " + (JSON.stringify((function() {
        var _ref, _results;
        _ref = this._found_sites;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          _results.push(k);
        }
        return _results;
      }).call(this))) + " were found but not specified");
    };

    return WebAssert;

  })(Assert);

  SocialNetworkAssert = (function(_super) {
    __extends(SocialNetworkAssert, _super);

    function SocialNetworkAssert() {
      return SocialNetworkAssert.__super__.constructor.apply(this, arguments);
    }

    SocialNetworkAssert.prototype.set_payload = function(o) {
      var _ref, _ref1;
      return this._username = o != null ? (_ref = o.body) != null ? (_ref1 = _ref.service) != null ? _ref1.username : void 0 : void 0 : void 0;
    };

    SocialNetworkAssert.prototype.check = function() {
      var ret;
      ret = SocialNetworkAssert.__super__.check.call(this);
      if (!ret) {

      } else if (this._username !== this.val) {
        log.error("Failed assertion for '" + this.key + "': " + this.val + " expected, but found " + this._username);
      } else {
        ret = true;
      }
      return ret;
    };

    SocialNetworkAssert.prototype.generate_unspecified_warning = function() {
      return log.warn("Assertion " + this.key + ":" + this._username + " was found but wasn't specified");
    };

    return SocialNetworkAssert;

  })(Assert);

  TwitterAssert = (function(_super) {
    __extends(TwitterAssert, _super);

    function TwitterAssert() {
      return TwitterAssert.__super__.constructor.apply(this, arguments);
    }

    return TwitterAssert;

  })(SocialNetworkAssert);

  GithubAssert = (function(_super) {
    __extends(GithubAssert, _super);

    function GithubAssert() {
      return GithubAssert.__super__.constructor.apply(this, arguments);
    }

    return GithubAssert;

  })(SocialNetworkAssert);

  exports.parse = function(v) {
    var ass, assert, err, m, out, _i, _len, _ref;
    out = new Assertions();
    for (_i = 0, _len = v.length; _i < _len; _i++) {
      ass = v[_i];
      if ((m = ass.match(/^([^\s:]+):(.*)$/))) {
        _ref = Assert.make(m[1], m[2]), err = _ref[0], assert = _ref[1];
      } else {
        err = new E.BadAssertionError("Bad assertion, couldn't parse: " + ass);
      }
      if (err != null) {
        break;
      }
      out.push(assert);
    }
    if (err != null) {
      out = null;
    }
    return [err, out];
  };

}).call(this);
